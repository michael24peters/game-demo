# Project Report
## Objective
Creating a game is well beyond the scope of this project. Too many components and too few members are involved to accomplish such a feat. That said, a problem that could be solved in designing this (or any indie game) is a strong backend and framework to minimize time spent debugging, testing, and writing documentation. In other words, this report will detail the game concept, design goals, backend setup, and everything involved in setting up this game for an easier future. There will also be a short demo provided for an example of how testing will occur, what branch conventions will be used, and how object-oriented design can be used to maximum effect.

The objective would be met if parts of a game were cohesively stitched together from a variety of different parts. This would put to the test !!

## Content
The game was be built using Python

As for game specifics, it will be constructed using a great deal of switch-cases or if-statements, branching into different paths of dialogue. Each “scenario” may be broken into a class (or function and sub-functions), which walk through the story of the main character.

Implementation
This game is currently run out of the terminal [...] use a package called Pygame, which is a beginner game engine that uses Python. Another option is Godot, which is based on Python but is much more widely used. A final — very compelling — option is GameMaker, which excels in 2D design and may make the process significantly easier. Games such as Heartbound, Risk of Rain, and Undertale were made using this engine. Ideally, I will use GameMaker (or Godot), but I may instead use Pygame if my time is limited.

[...] method of personal improvement in the game, algorithmically determined in a similar method to the Anki flashcard software (which is open-source). Based on difficulty (easy, good, hard, fail), certain things are emphasized or de-emphasized based on user input. I want to strike a balance between fun and creative with pragmatic and scientific.

1 hour of software setup (GitHub, branching, game engine research, big picture idea)
1 hour of game design (story, game mechanics)
2 hours of draft work (dialogue, scenarios, rough draft/pseudo-code functions)
4 hours of dialogue programming (lots of nested if-elif-else blocks, with emphasis on one-task functions, as well as experimenting with functional programming)
2 hours of mathematical functions (algorithms for progression, calculations, statistics for character and opponents, etc.)
2 hours of stitching (tying the project together into a cohesive whole, i.e. turning the mechanics, math, and dialogue into a game). Switch to game engine.
(If time) 4 hours of graphics design: map, movement, character model, sprites, etc.
(If time) 2 hours of user interface
(If time) 2 hours of sound work
